import 'package:portefeuille/core/data/models/transaction.dart';
import 'package:portefeuille/core/data/models/transaction_type.dart';
import 'package:portefeuille/core/data/models/asset_type.dart';
import 'package:portefeuille/features/00_app/providers/transaction_provider.dart';
import 'package:portefeuille/features/00_app/providers/portfolio_provider.dart';
import 'package:portefeuille/features/09_imports/services/import_diff_service.dart';
import 'package:portefeuille/features/09_imports/services/models/import_mode.dart';
import 'package:portefeuille/core/data/models/asset_metadata.dart';
import 'package:uuid/uuid.dart';

class ImportSaveService {
  static const _uuid = Uuid();
  /// Sauvegarde les transactions s√©lectionn√©es.
  /// 
  /// Pour les imports crowdfunding, cr√©e automatiquement un d√©p√¥t compensatoire
  /// par date unique d'investissement pour neutraliser l'impact sur les liquidit√©s.
  /// Cela refl√®te le fait que l'argent √©tait d√©j√† disponible avant l'import.
  static Future<int> saveSelected({
    required TransactionProvider provider,
    required PortfolioProvider portfolioProvider,
    required List<ImportCandidate> candidates,
    required String accountId,
    required ImportMode mode,
    required String? sourceId,
    Map<String, AssetMetadata>? metadataByTicker,
  }) async {
    final selectedCandidates = candidates.where((c) => c.selected).toList();
    if (selectedCandidates.isEmpty) return 0;

    final modeLabel = mode == ImportMode.update ? 'Actualisation' : 'Import initial';

    final newCandidates = selectedCandidates.where((c) => c.existingMatch == null).toList();
    final modifiedCandidates = selectedCandidates.where((c) => c.existingMatch != null).toList();

    if (newCandidates.isNotEmpty) {
      final List<Transaction> transactions = [];
      
      // Grouper les achats par date pour cr√©er un seul d√©p√¥t compensatoire par date
      // Conserver un flag par date si c'est du crowdfunding (pour le libell√© des notes)
      final Map<String, double> depositsByDate = {};
      final Map<String, bool> depositIsCrowdfundingByDate = {};
      final Map<String, List<String>> depositAssetsByDate = {}; // Pour les notes d√©taill√©es
      
      for (final candidate in newCandidates) {
        final parsed = candidate.parsed;
        
        // Cr√©er la transaction (id born√© en taille via UUID)
        transactions.add(Transaction(
          id: _uuid.v4(),
          accountId: accountId,
          type: parsed.type,
          date: parsed.date,
          assetTicker: parsed.ticker ?? parsed.isin,
          assetName: parsed.assetName,
          quantity: parsed.quantity,
          price: parsed.price,
          amount: parsed.amount,
          fees: parsed.fees,
          notes: "$modeLabel depuis $sourceId",
          assetType: parsed.assetType,
          priceCurrency: parsed.currency,
          isAutoGenerated: false,
        ));
        
        // Neutralisation des imports de TOUS les achats ET retraits
        // Logique :
        // - Buy (montant < 0) : Achat historique, argent d√©j√† d√©pens√© ‚Üí d√©p√¥t compensatoire
        // - Withdrawal (montant < 0) : Retrait historique, argent d√©j√† retir√© ‚Üí d√©p√¥t compensatoire
        // 
        // Raison : Lors d'un import, on ajoute l'historique transactionnel d'un compte
        // qui existait D√âJ√Ä avec des mouvements pass√©s (achats, retraits).
        // Sans compensation, les liquidit√©s seraient artificiellement n√©gatives.
        // Exemple : Import d'un compte avec 3 achats pour -8500‚Ç¨ ‚Üí Sans compensation : -8500‚Ç¨
        // (faux, car l'argent existait au moment des achats)
        //
        // Les Deposit et Interest NE sont PAS compens√©s car ils augmentent les liquidit√©s
        // (le montant n√©gatif des Buy/Withdrawal est √©quilibr√© par un Deposit positif)
        if ((parsed.type == TransactionType.Buy || parsed.type == TransactionType.Withdrawal) 
            && parsed.amount < 0) {
          final dateKey = parsed.date.toIso8601String().substring(0, 10);
          final isCrowdfunding = parsed.assetType == AssetType.RealEstateCrowdfunding;
          
          depositsByDate[dateKey] =
              (depositsByDate[dateKey] ?? 0) + parsed.amount.abs();
          depositIsCrowdfundingByDate[dateKey] =
              (depositIsCrowdfundingByDate[dateKey] ?? false) || isCrowdfunding;
          
          // Collecter les actifs pour la note d√©taill√©e
          if (!depositAssetsByDate.containsKey(dateKey)) {
            depositAssetsByDate[dateKey] = [];
          }
          final typeLabel = parsed.type == TransactionType.Buy ? 'Achat' : 'Retrait';
          depositAssetsByDate[dateKey]!.add(
            '$typeLabel: ${parsed.assetName} ${parsed.quantity.toStringAsFixed(2)}@${parsed.price.toStringAsFixed(2)}‚Ç¨'
          );
        }
      }
      
      // Cr√©er les d√©p√¥ts compensatoires pour neutraliser l'impact sur les liquidit√©s
      for (final entry in depositsByDate.entries) {
        final dateStr = entry.key;
        final amount = entry.value;
        final date = DateTime.parse(dateStr);
        
        final isCrowd = depositIsCrowdfundingByDate[dateStr] == true;
        final assets = depositAssetsByDate[dateStr] ?? [];
        final assetDetails = assets.length <= 3 
          ? assets.join(', ') 
          : '${assets.length} transactions';
        
        final noteContent = isCrowd
            ? 'ü§ñ Apport auto - Crowdfunding\n${modeLabel.toLowerCase()} depuis $sourceId\nMontant: ${amount.toStringAsFixed(2)}‚Ç¨'
            : 'ü§ñ Apport auto - Neutralisation\n${modeLabel.toLowerCase()} depuis $sourceId\n$assetDetails\nMontant: ${amount.toStringAsFixed(2)}‚Ç¨';
        
        transactions.add(Transaction(
          id: _uuid.v4(),
          accountId: accountId,
          type: TransactionType.Deposit,
          date: date,
          amount: amount,
          notes: noteContent,
          priceCurrency: 'EUR',
          isAutoGenerated: true,
        ));
      }
      
      await provider.addTransactions(transactions);
    }

    for (final candidate in modifiedCandidates) {
      final existing = candidate.existingMatch!;
      final updated = Transaction(
        id: existing.id,
        accountId: existing.accountId,
        type: existing.type,
        date: existing.date,
        assetTicker: existing.assetTicker,
        assetName: existing.assetName,
        quantity: candidate.parsed.quantity,
        price: candidate.parsed.price,
        amount: candidate.parsed.amount,
        fees: candidate.parsed.fees ?? existing.fees,
        notes: "Mise √† jour ($modeLabel) depuis $sourceId",
        assetType: existing.assetType,
        priceCurrency: candidate.parsed.currency ?? existing.priceCurrency,
        isAutoGenerated: existing.isAutoGenerated,
      );
      await provider.updateTransaction(updated);
    }

    return selectedCandidates.length;
  }
}
