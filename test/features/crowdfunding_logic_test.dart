import 'dart:io';
import 'package:flutter_test/flutter_test.dart';
import 'package:portefeuille/core/data/models/asset.dart';
import 'package:portefeuille/core/data/models/account.dart';
import 'package:portefeuille/core/data/models/account_type.dart';
import 'package:portefeuille/core/data/models/asset_metadata.dart';
import 'package:portefeuille/core/data/models/asset_type.dart';
import 'package:portefeuille/core/data/models/institution.dart';
import 'package:portefeuille/core/data/models/portfolio.dart';
import 'package:portefeuille/core/data/models/repayment_type.dart';
import 'package:portefeuille/core/data/models/transaction.dart';
import 'package:portefeuille/core/data/models/transaction_type.dart';
import 'package:portefeuille/core/data/repositories/portfolio_repository.dart';
import 'package:portefeuille/features/00_app/services/crowdfunding_service.dart';
import '../test_harness.dart';

void main() {
  late Directory tempDir;
  late PortfolioRepository repository;

  setUpAll(() async {
    tempDir = await initTestHive();
    repository = PortfolioRepository();
  });

  tearDownAll(() async {
    await tearDownTestHive(tempDir);
  });

  setUp(() async {
    await repository.deleteAllData();
  });

  test('Crowdfunding Logic: Buy Transaction -> Asset Creation -> Projections', () async {
    // 1. Setup Portfolio Structure
    final portfolio = repository.createEmptyPortfolio("Test Portfolio");
    
    final account = Account(
      id: "acc_1",
      name: "Livret Crowdfunding",
      type: AccountType.crowdfunding,
      currency: "EUR",
    );

    final institution = Institution(
      id: "inst_1",
      name: "La Première Brique", // The Platform
      accounts: [account],
    );

    portfolio.institutions.add(institution);
    await repository.savePortfolio(portfolio);

    // 2. Create a Buy Transaction for a Crowdfunding Project
    final buyTx = Transaction(
      id: "tx_1",
      accountId: account.id,
      type: TransactionType.Buy,
      date: DateTime.now().subtract(const Duration(days: 30)), // Bought 1 month ago
      amount: -1000.0, // Invested 1000 EUR
      quantity: 1000.0, // 1000 units (often 1€ per unit)
      price: 1.0,
      assetTicker: "PROJET_ALPHA",
      assetName: "Projet Alpha",
      assetType: AssetType.RealEstateCrowdfunding,
      priceCurrency: "EUR",
      exchangeRate: 1.0,
    );

    await repository.saveTransaction(buyTx);

    // 3. Create Metadata for this Project
    final metadata = AssetMetadata(
      ticker: "PROJET_ALPHA",
      projectName: "Projet Alpha",
      expectedYield: 10.0, // 10%
      targetDuration: 12, // 12 months
      repaymentType: RepaymentType.InFine,
      assetTypeDetailed: 'RealEstateCrowdfunding',
    );
    await repository.saveAssetMetadata(metadata);

    // 4. Reload Portfolio to trigger Asset Generation
    final portfolios = repository.getAllPortfolios();
    final loadedPortfolio = portfolios.first;
    final loadedAccount = loadedPortfolio.institutions.first.accounts.first;
    
    // ASSERTIONS: Asset Creation
    expect(loadedAccount.assets.length, 1);
    final asset = loadedAccount.assets.first;
    expect(asset.ticker, "PROJET_ALPHA");
    expect(asset.name, "Projet Alpha");
    expect(asset.type, AssetType.RealEstateCrowdfunding);
    expect(asset.quantity, 1000.0);
    expect(asset.totalInvestedCapital, 1000.0);

    // 5. Inject Metadata into Asset (Simulate Provider logic)
    // In the app, this is done by the PortfolioProvider or UI logic merging metadata.
    // For the service test, we manually inject relevant fields if the service needs them.
    // However, CrowdfundingService reads from the Asset object. 
    // The Asset object generated by Account.generateAssetsFromTransactions DOES NOT contain metadata fields 
    // (like targetDuration) because those are in the AssetMetadata box, not the Transaction.
    // 
    // Wait, the Asset model HAS fields for crowdfunding (targetDuration, etc.).
    // But `Account.generateAssetsFromTransactions` creates assets purely from Transactions.
    // Transactions DO NOT store targetDuration.
    // So the Asset created by the repository is "naked".
    //
    // The UI/Provider is responsible for "enriching" the Asset with Metadata before passing it to the Service?
    // OR the Service should look up Metadata?
    //
    // Let's check CrowdfundingService again.
    // It uses `asset.targetDuration`.
    //
    // So we need to ensure the Asset passed to the service has these fields set.
    // In the real app, `PortfolioProvider` likely merges this info.
    // Let's simulate that merge here.

    final enrichedAsset = asset.copyWith(
      targetDuration: metadata.targetDuration,
      expectedYield: metadata.expectedYield,
      repaymentType: metadata.repaymentType,
    );

    // 6. Generate Projections
    final service = CrowdfundingService();
    final projections = service.generateProjections([enrichedAsset]);

    // ASSERTIONS: Projections
    // We expect projections because duration > 0 and yield > 0.
    // Since it's InFine, we expect Interest + Capital at the end.
    // End date = Start Date + 12 months.
    
    expect(projections.isNotEmpty, true);
    
    // Check for Interest
    final interestProj = projections.where((p) => p.type == TransactionType.Interest);
    expect(interestProj.isNotEmpty, true);
    
    // Check for Capital Repayment (if implemented in service for InFine)
    // Reading the service code earlier:
    // if (endDate.isAfter(now)) { ... add InterestPayment ... add CapitalRepayment ... }
    // Note: The service code I read earlier used TransactionType.InterestPayment (which I removed).
    // I replaced it with TransactionType.Interest.
    // Let's verify the service logic for CapitalRepayment.
    
    final capitalProj = projections.where((p) => p.type == TransactionType.CapitalRepayment);
    // If the service implements it, it should be there.
    
    // Calculate expected interest
    // 1000 * 10% * (12/12) = 100 EUR
    final totalInterest = interestProj.fold(0.0, (sum, p) => sum + p.amount);
    expect(totalInterest, closeTo(100.0, 0.1));
  });
}

// Helper extension to simulate copyWith since Asset might not have a full copyWith or it might be tedious
extension AssetCopyWith on Asset {
  Asset copyWith({
    int? targetDuration,
    double? expectedYield,
    RepaymentType? repaymentType,
  }) {
    // We create a new Asset with the same ID/Transactions but updated metadata fields
    // This mimics what the UI does when it displays the asset combined with metadata
    final newAsset = Asset(
      id: id,
      name: name,
      ticker: ticker,
      type: type,
      transactions: transactions,
      priceCurrency: priceCurrency,
      currentExchangeRate: currentExchangeRate,
      // Injected fields
      targetDuration: targetDuration ?? this.targetDuration,
      expectedYield: expectedYield ?? this.expectedYield,
      repaymentType: repaymentType ?? this.repaymentType,
    );
    return newAsset;
  }
}
